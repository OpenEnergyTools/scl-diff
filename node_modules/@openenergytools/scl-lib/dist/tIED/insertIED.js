import { createElement } from "../foundation/utils.js";
import { getReference } from "../tBaseElement/getReference.js";
/**
 * Copies an SCL SubNetwork element but without its ConnectedAP children.
 * @param subNetwork - SCL SubNetwork element.
 * @returns cloned SubNetwork without Element children.
 */
function getNewSubNetwork(subNetwork) {
    const newSubNetwork = subNetwork.cloneNode(true);
    newSubNetwork.childNodes.forEach((childNode) => {
        if (childNode.nodeType === Node.ELEMENT_NODE &&
            childNode.nodeName === "ConnectedAP")
            newSubNetwork.removeChild(childNode);
    });
    return newSubNetwork;
}
function addCommunicationElements(newIed, scl) {
    const edits = [];
    const existingCommunication = scl.querySelector(":root > Communication");
    const communication = existingCommunication
        ? existingCommunication
        : createElement(scl.ownerDocument, "Communication", {});
    if (!existingCommunication)
        edits.push({
            parent: scl,
            node: communication,
            reference: getReference(scl, "Communication"),
        });
    const subNetworks = Array.from(newIed.ownerDocument.querySelectorAll(":root > Communication > SubNetwork")).filter((subNetwork) => subNetwork.querySelector(`:scope > ConnectedAP[iedName="${newIed.getAttribute("name")}"]`));
    subNetworks.forEach((subNetwork) => {
        const connectedAps = Array.from(subNetwork.querySelectorAll(`:scope > ConnectedAP[iedName="${newIed.getAttribute("name")}"]`));
        const existingSubNetwork = communication.querySelector(`:root > Communication > SubNetwork[name="${subNetwork?.getAttribute("name")}"]`);
        const usedSubNetwork = existingSubNetwork
            ? existingSubNetwork
            : getNewSubNetwork(subNetwork);
        if (!existingSubNetwork)
            edits.push({
                parent: communication,
                node: usedSubNetwork,
                reference: getReference(communication, "SubNetwork"),
            });
        connectedAps.forEach((connectedAp) => {
            const iedName = newIed.getAttribute("name");
            const apName = connectedAp.getAttribute("apName");
            const existingConnectedAp = existingSubNetwork?.querySelector(`:scope > ConnectedAP[iedName="${iedName}"][apName="${apName}"]`);
            if (!existingConnectedAp) {
                const connectedAP = connectedAp.cloneNode(true);
                edits.push({
                    parent: usedSubNetwork,
                    node: connectedAP,
                    reference: getReference(usedSubNetwork, "ConnectedAP"),
                });
            }
        });
    });
    return edits;
}
function isDataTypeConnectionToIed(dataType, newIed) {
    const dataTypeTemplates = dataType.parentElement;
    const id = dataType.getAttribute("id");
    if (!dataTypeTemplates || !id)
        return false;
    if (dataType.tagName === "EnumType")
        return Array.from(dataTypeTemplates.querySelectorAll(`DOType > DA[type="${id}"],DAType > BDA[type="${id}"]`)).some((typeChild) => isDataTypeConnectionToIed(typeChild.parentElement, newIed));
    if (dataType.tagName === "DAType")
        return Array.from(dataTypeTemplates.querySelectorAll(`DOType > DA[type="${id}"],DAType > BDA[type="${id}"]`)).some((typeChild) => isDataTypeConnectionToIed(typeChild.parentElement, newIed));
    if (dataType.tagName === "DOType")
        return Array.from(dataTypeTemplates.querySelectorAll(`LNodeType > DO[type="${id}"], DOType > SDO[type="${id}"]`)).some((typeChild) => isDataTypeConnectionToIed(typeChild.parentElement, newIed));
    return Array.from(newIed.getElementsByTagName("LN0"))
        .concat(Array.from(newIed.getElementsByTagName("LN")))
        .some((anyLn) => anyLn.getAttribute("lnType") === id);
}
/**
 * Generates a new DTT section id in case of a collision by adding a number in hex
 * prefixed with an underscore to the existing id.
 *
 * @param existingId - Existing string for id attribute.
 * @param existingLNodeType - Existing LNodeType for which a new ID is required.
 * @param dataTypeTemplates - Existing Element of DTTs from the SCL file.
 * @returns New string which is unique in the DTT section.
 */
function generateNewId(existingId, newIed, existingLNodeType, dataTypeTemplates) {
    const iedName = newIed.getAttribute("name");
    const tagType = existingLNodeType.tagName;
    const duplicatesFound = function (counter) {
        return !!dataTypeTemplates.querySelector(`${tagType}[id="${existingId}@${iedName}#${counter.toString(10)}"]`);
    };
    let counter = 1;
    // 2,000 limit reasonable way to avoid infinite loop
    while (duplicatesFound(counter) && counter < 2000) {
        counter += 1;
    }
    return `${existingId}@${iedName}#${counter.toString(10)}`;
}
function addEnumType(newIed, newEnumType, oldDataTypeTemplates) {
    if (!isDataTypeConnectionToIed(newEnumType, newIed))
        return;
    const existEnumType = oldDataTypeTemplates.querySelector(`EnumType[id="${newEnumType.getAttribute("id")}"]`);
    if (existEnumType && newEnumType.isEqualNode(existEnumType))
        return;
    if (existEnumType) {
        // There is an `id` conflict in the project that must be resolved by
        // concatenating the IED name with the id
        const data = newEnumType.parentElement;
        const idOld = newEnumType.getAttribute("id");
        const idNew = generateNewId(idOld, newIed, existEnumType, oldDataTypeTemplates);
        newEnumType.setAttribute("id", idNew);
        data
            .querySelectorAll(`DOType > DA[type="${idOld}"],DAType > BDA[type="${idOld}"]`)
            .forEach((type) => type.setAttribute("type", idNew));
    }
    return {
        parent: oldDataTypeTemplates,
        node: newEnumType,
        reference: getReference(oldDataTypeTemplates, "EnumType"),
    };
}
function addDAType(newIed, newDAType, oldDataTypeTemplates) {
    if (!isDataTypeConnectionToIed(newDAType, newIed))
        return;
    const existDAType = oldDataTypeTemplates.querySelector(`DAType[id="${newDAType.getAttribute("id")}"]`);
    if (existDAType && newDAType.isEqualNode(existDAType))
        return;
    if (existDAType) {
        // There is an `id` conflict in the project that must be resolved by
        // concatenating the IED name with the id
        const data = newDAType.parentElement;
        const idOld = newDAType.getAttribute("id");
        const idNew = generateNewId(idOld, newIed, existDAType, oldDataTypeTemplates);
        newDAType.setAttribute("id", idNew);
        data
            .querySelectorAll(`DOType > DA[type="${idOld}"],DAType > BDA[type="${idOld}"]`)
            .forEach((type) => type.setAttribute("type", idNew));
    }
    return {
        parent: oldDataTypeTemplates,
        node: newDAType,
        reference: getReference(oldDataTypeTemplates, "DAType"),
    };
}
function addDOType(newIed, newDOType, oldDataTypeTemplates) {
    if (!isDataTypeConnectionToIed(newDOType, newIed))
        return;
    const existDOType = oldDataTypeTemplates.querySelector(`DOType[id="${newDOType.getAttribute("id")}"]`);
    if (existDOType && newDOType.isEqualNode(existDOType))
        return;
    if (existDOType) {
        // There is an `id` conflict in the project that must be resolved by
        // concatenating the IED name with the id
        const data = newDOType.parentElement;
        const idOld = newDOType.getAttribute("id");
        const idNew = generateNewId(idOld, newIed, existDOType, oldDataTypeTemplates);
        newDOType.setAttribute("id", idNew);
        data
            .querySelectorAll(`LNodeType > DO[type="${idOld}"], DOType > SDO[type="${idOld}"]`)
            .forEach((type) => type.setAttribute("type", idNew));
    }
    return {
        parent: oldDataTypeTemplates,
        node: newDOType,
        reference: getReference(oldDataTypeTemplates, "DOType"),
    };
}
function addLNodeType(newIed, newLNodeType, oldDataTypeTemplates) {
    if (!isDataTypeConnectionToIed(newLNodeType, newIed))
        return;
    const existLNodeType = oldDataTypeTemplates.querySelector(`LNodeType[id="${newLNodeType.getAttribute("id")}"]`);
    if (existLNodeType && newLNodeType.isEqualNode(existLNodeType))
        return;
    if (existLNodeType) {
        // There is an `id` conflict in the project that must be resolved by
        // concatenating the IED name with the id
        const idOld = newLNodeType.getAttribute("id");
        const idNew = generateNewId(idOld, newIed, existLNodeType, oldDataTypeTemplates);
        newLNodeType.setAttribute("id", idNew);
        Array.from(newIed.querySelectorAll(`LN0[lnType="${idOld}"],LN[lnType="${idOld}"]`))
            .filter((anyLn) => !anyLn.closest("Private"))
            .forEach((ln) => ln.setAttribute("lnType", idNew));
    }
    return {
        parent: oldDataTypeTemplates,
        node: newLNodeType,
        reference: getReference(oldDataTypeTemplates, "LNodeType"),
    };
}
function addDataTypeTemplates(newIed, scl) {
    const dataTypeEdit = [];
    const dataTypeTemplates = scl.querySelector(":root > DataTypeTemplates")
        ? scl.querySelector(":root > DataTypeTemplates")
        : createElement(scl.ownerDocument, "DataTypeTemplates", {});
    if (!dataTypeTemplates.parentElement) {
        dataTypeEdit.push({
            parent: scl,
            node: dataTypeTemplates,
            reference: getReference(scl, "DataTypeTemplates"),
        });
    }
    const typeEdits = [];
    newIed.ownerDocument
        .querySelectorAll(":root > DataTypeTemplates > EnumType")
        .forEach((enumType) => typeEdits.push(addEnumType(newIed, enumType, dataTypeTemplates)));
    newIed.ownerDocument
        .querySelectorAll(":root > DataTypeTemplates > DAType")
        .forEach((daType) => typeEdits.push(addDAType(newIed, daType, dataTypeTemplates)));
    newIed.ownerDocument
        .querySelectorAll(":root > DataTypeTemplates > DOType")
        .forEach((doType) => typeEdits.push(addDOType(newIed, doType, dataTypeTemplates)));
    newIed.ownerDocument
        .querySelectorAll(":root > DataTypeTemplates > LNodeType")
        .forEach((lNodeType) => typeEdits.push(addLNodeType(newIed, lNodeType, dataTypeTemplates)));
    return dataTypeEdit.concat(typeEdits.reverse().filter((item) => item !== undefined));
}
function isNameUnique(scl, ied) {
    return !!scl.querySelector(`IED[name="${ied.getAttribute("name")}"]`);
}
function isIED(node) {
    return node.tagName === "IED";
}
function isSCL(node) {
    return node.tagName === "SCL";
}
/** Function to import !single IEDs with its `DataTypeTemplates` and
 * optionally linked `Communication`section elements.
 * >NOTE: Element are MOVED from ied document to the project not copied
 * @param scl - the parent SCL element to insert the IED to
 * @param ied - the new IED to be added to the project (SCL)
 * @param options
 * @returns An array containing diff objects representing an import IED edit
 * section */
export function insertIed(scl, ied, options = { addCommunicationSection: true }) {
    if (!isSCL(scl) || !isIED(ied) || isNameUnique(scl, ied))
        return [];
    const insertCommunication = [];
    if (options.addCommunicationSection)
        insertCommunication.push(...addCommunicationElements(ied, scl));
    const insertDataTypes = [];
    insertDataTypes.push(...addDataTypeTemplates(ied, scl));
    const insertIed = {
        parent: scl,
        node: ied,
        reference: getReference(scl, "IED"),
    };
    return [...insertCommunication, insertIed, ...insertDataTypes];
}
//# sourceMappingURL=insertIED.js.map